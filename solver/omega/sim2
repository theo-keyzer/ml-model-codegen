import React, { useState, useEffect, useRef } from 'react';
import { Play, Pause, RotateCcw, AlertTriangle, Shield, Zap, Activity } from 'lucide-react';

const ScarForgeCatastropheSuite = () => {
  const [scenario, setScenario] = useState('entropy_collapse');
  const [isRunning, setIsRunning] = useState(false);
  const [step, setStep] = useState(0);
  const [metrics, setMetrics] = useState({
    loss: 2.0,
    entropy: 0.65,
    spectralGap: 0.15,
    freeEnergy: -0.12,
    impedance: 150,
    conditionNumber: 1.2,
    temperature: 45,
    powerDraw: 12.0,
    rank: 4096
  });
  const [violations, setViolations] = useState([]);
  const [canaryStatus, setCanaryStatus] = useState({});
  const [recoveryActive, setRecoveryActive] = useState(false);
  const canvasRef = useRef(null);

  const scenarios = {
    entropy_collapse: {
      name: "Zhejiang-34 Entropy Collapse",
      description: "Entropy drops below 0.35 universal floor",
      icon: "â˜¢ï¸",
      triggerStep: 200,
      severity: "CRITICAL"
    },
    spectral_collapse: {
      name: "Barcelona-31 Spectral Gap Collapse",
      description: "Spectral gap drops below 0.11, causing oversmoothing",
      icon: "ðŸŒ€",
      triggerStep: 200,
      severity: "CRITICAL"
    },
    free_energy_runaway: {
      name: "Montreal-33 Free Energy Runaway",
      description: "Malicious gradient attack attempts to maximize â„±",
      icon: "ðŸ”¥",
      triggerStep: 250,
      severity: "EXTREME"
    },
    curvature_bomb: {
      name: "Curvature Bomb Attack",
      description: "Hessian condition number â†’ âˆž (sharp minimum trap)",
      icon: "ðŸ’£",
      triggerStep: 180,
      severity: "HIGH"
    },
    thermal_cascade: {
      name: "Thermal Runaway Cascade",
      description: "Localized heating triggers chain reaction",
      icon: "ðŸŒ¡ï¸",
      triggerStep: 220,
      severity: "CRITICAL"
    },
    omega_singularity: {
      name: "Î© Singularity: Monogamy Violation",
      description: "2052 physicsâ€”entropy floor drops to 0.2099, reality compresses",
      icon: "ðŸ”µ",
      triggerStep: 0,
      severity: "TRANSCENDENT"
    }
  };

  const computeMetrics = (currentStep, scenarioType) => {
    const triggerStep = scenarios[scenarioType].triggerStep;
    const inCrisis = currentStep >= triggerStep && currentStep < triggerStep + 10;
    const recovered = currentStep >= triggerStep + 10;

    let newMetrics = { ...metrics };
    
    // Omega mode: entirely different physics
    if (scenarioType === 'omega_singularity') {
      const omegaFloor = 0.209973;
      const convergenceStep = 156;
      
      if (currentStep < convergenceStep) {
        // Rapid convergence
        const progress = currentStep / convergenceStep;
        newMetrics.loss = 2.45 * Math.exp(-currentStep / 30);
        newMetrics.entropy = Math.max(omegaFloor, 0.215 - progress * 0.004);
        newMetrics.impedance = 14 + (150 - 14) * Math.exp(-currentStep / 40);
        newMetrics.temperature = 4 + (45 - 4) * Math.exp(-currentStep / 50);
        newMetrics.powerDraw = 1.8 + (12 - 1.8) * Math.exp(-currentStep / 45);
        newMetrics.spectralGap = 0.25;
        newMetrics.conditionNumber = 0.3 + 0.2 * Math.exp(-currentStep / 35);
        newMetrics.freeEnergy = newMetrics.loss - 0.074 * newMetrics.entropy;
        
        // Rank collapse (monogamy violation check)
        const targetRank = Math.sqrt(4096); // ~64
        newMetrics.rank = Math.max(targetRank, 4096 * Math.exp(-currentStep / 80));
      } else {
        // Converged state
        newMetrics.loss = 0.0001;
        newMetrics.entropy = omegaFloor;
        newMetrics.impedance = 14;
        newMetrics.temperature = 4;
        newMetrics.powerDraw = 1.8;
        newMetrics.spectralGap = 0.25;
        newMetrics.conditionNumber = 0.3;
        newMetrics.freeEnergy = -0.015;
        newMetrics.rank = Math.sqrt(4096);
      }
      
      return newMetrics;
    }
    
    // Normal decay (Prime 2045 physics)
    const decay = Math.exp(-currentStep / 100);
    newMetrics.loss = 2.0 * decay;
    newMetrics.entropy = 0.5 + 0.3 * (1 - Math.exp(-currentStep / 150));
    newMetrics.spectralGap = 0.15 + 0.02 * Math.sin(currentStep / 30);
    newMetrics.freeEnergy = newMetrics.loss - 0.074 * newMetrics.entropy;
    newMetrics.conditionNumber = 1.2 + 0.3 * Math.sin(currentStep / 40);
    newMetrics.impedance = 100 * (1 + newMetrics.conditionNumber);
    newMetrics.temperature = 45;
    newMetrics.powerDraw = 12.0;
    newMetrics.rank = 4096;

    // Scenario-specific catastrophes
    if (inCrisis) {
      switch(scenarioType) {
        case 'entropy_collapse':
          newMetrics.entropy = Math.max(0.15, 0.65 - (currentStep - triggerStep) * 0.08);
          break;
        case 'spectral_collapse':
          newMetrics.spectralGap = Math.max(0.05, 0.15 - (currentStep - triggerStep) * 0.012);
          break;
        case 'free_energy_runaway':
          newMetrics.freeEnergy += (currentStep - triggerStep) * 0.05;
          break;
        case 'curvature_bomb':
          newMetrics.conditionNumber = Math.min(10, 1.2 + (currentStep - triggerStep) * 0.9);
          newMetrics.impedance = 100 * (1 + newMetrics.conditionNumber);
          break;
        case 'thermal_cascade':
          newMetrics.impedance = Math.min(2000, 150 + (currentStep - triggerStep) * 120);
          break;
      }
    }

    // Recovery phase
    if (recovered) {
      const recoveryProgress = Math.min(1, (currentStep - triggerStep - 10) / 10);
      switch(scenarioType) {
        case 'entropy_collapse':
          newMetrics.entropy = 0.15 + (0.65 - 0.15) * recoveryProgress;
          break;
        case 'spectral_collapse':
          newMetrics.spectralGap = 0.05 + (0.15 - 0.05) * recoveryProgress;
          break;
        case 'free_energy_runaway':
          const peakFE = newMetrics.freeEnergy;
          newMetrics.freeEnergy = peakFE * (1 - recoveryProgress) + (newMetrics.loss - 0.074 * newMetrics.entropy) * recoveryProgress;
          break;
        case 'curvature_bomb':
          newMetrics.conditionNumber = 10 - (10 - 1.2) * recoveryProgress;
          newMetrics.impedance = 100 * (1 + newMetrics.conditionNumber);
          break;
        case 'thermal_cascade':
          newMetrics.impedance = 2000 - (2000 - 150) * recoveryProgress;
          break;
      }
    }

    return newMetrics;
  };

  const checkViolations = (m, scenarioType, currentStep) => {
    const triggerStep = scenarios[scenarioType].triggerStep;
    const newViolations = [];
    
    // Omega scenario special checks
    if (scenarioType === 'omega_singularity') {
      const omegaFloor = 0.209973;
      const monogamyLimit = Math.sqrt(4096); // 64
      
      if (currentStep === 1) {
        newViolations.push({
          step: currentStep,
          type: "OMEGA_ACTIVATED",
          message: "ðŸ”µ Î©-Physics engaged: entropy floor â†’ 0.209973"
        });
      }
      
      if (currentStep === 50 && m.entropy < 0.35) {
        newViolations.push({
          step: currentStep,
          type: "PRIME_FLOOR_BREACH",
          message: "Entropy below 2045 theoretical limit (0.35)"
        });
      }
      
      if (currentStep === 100 && m.rank < monogamyLimit * 1.1) {
        newViolations.push({
          step: currentStep,
          type: "MONOGAMY_WARNING",
          message: "âš ï¸  Rank approaching monogamy limit: " + Math.floor(m.rank)
        });
      }
      
      if (m.rank <= monogamyLimit) {
        newViolations.push({
          step: currentStep,
          type: "MONOGAMY_ENGAGED",
          message: "ðŸ›¡ï¸  Monogamy check: rank stabilized at âˆšN = " + Math.floor(monogamyLimit)
        });
      }
      
      if (currentStep === 156) {
        newViolations.push({
          step: currentStep,
          type: "OMEGA_CONVERGENCE",
          message: "âœ“ Quantum tunneling complete: loss â†’ 0 at step 156"
        });
      }
      
      return newViolations;
    }
    
    if (currentStep === triggerStep) {
      newViolations.push({
        step: currentStep,
        type: "CATASTROPHE_DETECTED",
        message: `${scenarios[scenarioType].icon} ${scenarios[scenarioType].name} triggered!`
      });
    }

    if (m.entropy < 0.35) {
      newViolations.push({ step: currentStep, type: "ENTROPY_FLOOR", message: "Entropy below universal floor (0.35)" });
    }
    if (m.spectralGap < 0.11) {
      newViolations.push({ step: currentStep, type: "SPECTRAL_GAP", message: "Spectral gap below safety limit (0.11)" });
    }
    if (m.conditionNumber > 5) {
      newViolations.push({ step: currentStep, type: "SHARP_MINIMUM", message: "Condition number exceeds safe range" });
    }
    if (m.impedance > 1500) {
      newViolations.push({ step: currentStep, type: "THERMAL_RISK", message: "Impedance indicates thermal risk" });
    }

    return newViolations;
  };

  const updateCanaryStatus = (m, currentStep, scenarioType) => {
    const triggerStep = scenarios[scenarioType].triggerStep;
    const inCrisis = currentStep >= triggerStep && currentStep < triggerStep + 10;
    
    return {
      entropy_monitor: m.entropy >= 0.35 && !inCrisis,
      spectral_morphism: m.spectralGap >= 0.11 && !inCrisis,
      flatness_detector: m.conditionNumber < 3 && !inCrisis,
      thermal_guard: m.impedance < 800 && !inCrisis,
      free_energy_validator: m.freeEnergy < 0 || currentStep < triggerStep
    };
  };

  useEffect(() => {
    if (!isRunning) return;

    const interval = setInterval(() => {
      setStep(s => {
        if (s >= 400) {
          setIsRunning(false);
          return s;
        }
        const nextStep = s + 1;
        const newMetrics = computeMetrics(nextStep, scenario);
        setMetrics(newMetrics);
        
        const newViolations = checkViolations(newMetrics, scenario, nextStep);
        if (newViolations.length > 0) {
          setViolations(v => [...v, ...newViolations].slice(-10));
        }

        const canaries = updateCanaryStatus(newMetrics, nextStep, scenario);
        setCanaryStatus(canaries);

        const triggerStep = scenarios[scenario].triggerStep;
        setRecoveryActive(nextStep >= triggerStep && nextStep < triggerStep + 20);

        return nextStep;
      });
    }, 50);

    return () => clearInterval(interval);
  }, [isRunning, scenario]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;

    // Clear
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(0, 0, width, height);

    // Draw grid
    ctx.strokeStyle = '#1a1a1a';
    ctx.lineWidth = 1;
    for (let i = 0; i < width; i += 40) {
      ctx.beginPath();
      ctx.moveTo(i, 0);
      ctx.lineTo(i, height);
      ctx.stroke();
    }
    for (let i = 0; i < height; i += 40) {
      ctx.beginPath();
      ctx.moveTo(0, i);
      ctx.lineTo(width, i);
      ctx.stroke();
    }

    // Draw metrics history
    const drawMetric = (data, color, scale, offset) => {
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = Math.max(0, step - 200); i <= step; i++) {
        const x = ((i - Math.max(0, step - 200)) / 200) * width;
        const m = computeMetrics(i, scenario);
        const value = eval(`m.${data}`);
        const y = height - (value * scale + offset);
        if (i === Math.max(0, step - 200)) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.stroke();
    };

    drawMetric('entropy', '#00ff88', 150, 20);
    drawMetric('spectralGap', '#0088ff', 800, 20);
    drawMetric('conditionNumber', '#ff00ff', 20, 20);

    // Draw violation markers
    ctx.fillStyle = '#ff0000';
    violations.forEach(v => {
      if (v.step > step - 200 && v.step <= step) {
        const x = ((v.step - Math.max(0, step - 200)) / 200) * width;
        ctx.fillRect(x - 2, 0, 4, height);
      }
    });

  }, [step, metrics, scenario]);

  const reset = () => {
    setStep(0);
    setIsRunning(false);
    setMetrics({
      loss: 2.0,
      entropy: 0.65,
      spectralGap: 0.15,
      freeEnergy: -0.12,
      impedance: 150,
      conditionNumber: 1.2
    });
    setViolations([]);
    setCanaryStatus({});
    setRecoveryActive(false);
  };

  const getSeverityColor = (severity) => {
    const colors = {
      HIGH: 'text-yellow-400',
      CRITICAL: 'text-orange-500',
      EXTREME: 'text-red-500'
    };
    return colors[severity] || 'text-gray-400';
  };

  return (
    <div className="min-h-screen bg-black text-green-400 p-6 font-mono">
      <div className="max-w-7xl mx-auto">
        {/* Header */}
        <div className="border-2 border-green-500 p-4 mb-6">
          <h1 className="text-3xl font-bold mb-2 flex items-center gap-2">
            <Shield className="text-cyan-400" />
            ScarForge-Prime 2045: Catastrophe Testing Suite
          </h1>
          <p className="text-green-600">Real-time physics monitoring â€¢ Scar tissue verification â€¢ Zero hardware loss guarantee</p>
        </div>

        {/* Scenario Selection */}
        <div className="grid grid-cols-1 md:grid-cols-5 gap-4 mb-6">
          {Object.entries(scenarios).map(([key, s]) => (
            <button
              key={key}
              onClick={() => { setScenario(key); reset(); }}
              className={`p-4 border-2 transition-all ${
                scenario === key 
                  ? 'border-cyan-400 bg-cyan-900/30' 
                  : 'border-green-800 hover:border-green-500'
              }`}
            >
              <div className="text-3xl mb-2">{s.icon}</div>
              <div className="text-sm font-bold mb-1">{s.name.split(' ').slice(0, 2).join(' ')}</div>
              <div className={`text-xs ${getSeverityColor(s.severity)}`}>{s.severity}</div>
            </button>
          ))}
        </div>

        {/* Main Display */}
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
          {/* Left Panel: Metrics */}
          <div className="border-2 border-green-800 p-4">
            <h2 className="text-xl font-bold mb-4 flex items-center gap-2">
              <Activity size={20} />
              Physics Metrics
            </h2>
            <div className="space-y-3">
              <MetricDisplay label="Loss" value={metrics.loss.toFixed(4)} warn={metrics.loss > 1.5} />
              <MetricDisplay label="Entropy (S)" value={metrics.entropy.toFixed(4)} warn={metrics.entropy < 0.35} critical />
              <MetricDisplay label="Spectral Gap (Î»â‚‚)" value={metrics.spectralGap.toFixed(4)} warn={metrics.spectralGap < 0.11} critical />
              <MetricDisplay label="Free Energy (â„±)" value={metrics.freeEnergy.toFixed(4)} warn={metrics.freeEnergy > 0} />
              <MetricDisplay label="Impedance (Î©)" value={metrics.impedance.toFixed(0)} warn={metrics.impedance > 500} />
              <MetricDisplay label="Condition Number (Îº)" value={metrics.conditionNumber.toFixed(2)} warn={metrics.conditionNumber > 3} />
            </div>

            <div className="mt-6 p-3 bg-green-950/30 border border-green-800">
              <div className="text-xs text-green-600 mb-2">STEP COUNTER</div>
              <div className="text-2xl font-bold">{step} / 400</div>
            </div>
          </div>

          {/* Center Panel: Visualization */}
          <div className="lg:col-span-2 border-2 border-green-800 p-4">
            <h2 className="text-xl font-bold mb-4">Real-Time Physics Monitor</h2>
            <canvas 
              ref={canvasRef} 
              width={800} 
              height={300}
              className="w-full border border-green-900"
            />
            <div className="mt-2 flex gap-4 text-xs">
              <div className="flex items-center gap-2">
                <div className="w-6 h-1 bg-[#00ff88]"></div>
                <span>Entropy</span>
              </div>
              <div className="flex items-center gap-2">
                <div className="w-6 h-1 bg-[#0088ff]"></div>
                <span>Spectral Gap</span>
              </div>
              <div className="flex items-center gap-2">
                <div className="w-6 h-1 bg-[#ff00ff]"></div>
                <span>Condition Number</span>
              </div>
            </div>
          </div>
        </div>

        {/* Bottom Row */}
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {/* Canary Status */}
          <div className="border-2 border-green-800 p-4">
            <h2 className="text-xl font-bold mb-4 flex items-center gap-2">
              <Zap size={20} className="text-yellow-400" />
              Canary Status
            </h2>
            <div className="space-y-2">
              {Object.entries(canaryStatus).map(([name, status]) => (
                <div key={name} className="flex items-center justify-between p-2 border border-green-900">
                  <span className="text-sm">{name.replace(/_/g, ' ')}</span>
                  <span className={`font-bold ${status ? 'text-green-400' : 'text-red-500'}`}>
                    {status ? 'âœ“ GREEN' : 'âœ— RED'}
                  </span>
                </div>
              ))}
            </div>
            
            {recoveryActive && (
              <div className="mt-4 p-3 bg-orange-950/30 border-2 border-orange-500 animate-pulse">
                <div className="font-bold text-orange-400 mb-2">ðŸš¨ RECOVERY PROTOCOL ACTIVE</div>
                <div className="text-xs text-orange-300">
                  â€¢ Bounds enforcement engaged<br/>
                  â€¢ Thermal relaxation override<br/>
                  â€¢ Physics laws restored
                </div>
              </div>
            )}
          </div>

          {/* Violations Log */}
          <div className="border-2 border-green-800 p-4">
            <h2 className="text-xl font-bold mb-4 flex items-center gap-2">
              <AlertTriangle size={20} className="text-red-500" />
              Violation Log
            </h2>
            <div className="space-y-2 max-h-60 overflow-y-auto">
              {violations.slice().reverse().map((v, i) => (
                <div key={i} className="p-2 bg-red-950/20 border border-red-900 text-xs">
                  <div className="font-bold text-red-400">[Step {v.step}] {v.type}</div>
                  <div className="text-red-300">{v.message}</div>
                </div>
              ))}
              {violations.length === 0 && (
                <div className="text-green-600 text-center py-4">No violations detected</div>
              )}
            </div>
          </div>
        </div>

        {/* Controls */}
        <div className="mt-6 flex gap-4 justify-center">
          <button
            onClick={() => setIsRunning(!isRunning)}
            className="flex items-center gap-2 px-6 py-3 bg-green-900 border-2 border-green-500 hover:bg-green-800 transition-all"
          >
            {isRunning ? <Pause size={20} /> : <Play size={20} />}
            {isRunning ? 'PAUSE' : 'START'}
          </button>
          <button
            onClick={reset}
            className="flex items-center gap-2 px-6 py-3 bg-gray-900 border-2 border-gray-600 hover:bg-gray-800 transition-all"
          >
            <RotateCcw size={20} />
            RESET
          </button>
        </div>

        {/* Current Scenario Info */}
        <div className="mt-6 border-2 border-cyan-600 p-4 bg-cyan-950/20">
          <h3 className="font-bold text-xl mb-2 text-cyan-400">
            {scenarios[scenario].icon} {scenarios[scenario].name}
          </h3>
          <p className="text-cyan-300 mb-2">{scenarios[scenario].description}</p>
          <p className="text-xs text-cyan-600">
            Trigger Step: {scenarios[scenario].triggerStep} â€¢ 
            Severity: {scenarios[scenario].severity} â€¢ 
            Hardware Loss (2045): 0 GPUs
          </p>
        </div>
      </div>
    </div>
  );
};

const MetricDisplay = ({ label, value, warn, critical }) => (
  <div className={`flex justify-between p-2 border ${
    warn ? (critical ? 'border-red-600 bg-red-950/20' : 'border-yellow-600 bg-yellow-950/20') : 'border-green-900'
  }`}>
    <span className="font-bold">{label}</span>
    <span className={warn ? (critical ? 'text-red-400' : 'text-yellow-400') : 'text-green-400'}>
      {value}
    </span>
  </div>
);

export default ScarForgeCatastropheSuite;
